generator client {
  provider = "prisma-client"
  output   = "./generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ============================================
// USER & ATHLETE
// ============================================

model User {
  id          String      @id @default(cuid())
  clerkId     String      @unique
  email       String      @unique
  accountType AccountType @default(ATHLETE) // Primary mode, but users can be both
  role        Role        @default(ATHLETE)
  
  // Suspension
  suspendedAt    DateTime?  // If set, user is suspended
  suspendedBy    String?    // ID of admin who suspended
  suspendReason  String?    // Reason for suspension
  
  // Review permissions (for peer reviews on social feed)
  canReview         Boolean   @default(true)   // Can this user review submissions?
  reviewBannedAt    DateTime? // When they were banned from reviewing
  reviewBannedBy    String?   // Admin who banned them
  reviewBanReason   String?   // Why they were banned
  reviewCount       Int       @default(0)      // Total reviews given
  reviewAccuracy    Float?    // % of reviews that matched final outcome (quality metric)
  
  // Fitness app connections (Strava/Garmin)
  stravaAthleteId     String?   @unique
  stravaAccessToken   String?
  stravaRefreshToken  String?
  stravaConnectedAt   DateTime?
  garminUserId        String?   @unique
  garminAccessToken   String?
  garminRefreshToken  String?
  garminConnectedAt   DateTime?
  
  // Unit preferences for training display
  unitSystem          String    @default("metric") // "metric" or "imperial"
  
  // Parent consent for child activity sharing (COPPA compliance)
  shareChildActivity  Boolean   @default(false) // Can parent share child achievements in feed
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  // User's own athlete profile (if they compete themselves)
  athlete Athlete? @relation("UserAthlete")

  // Child athletes this user manages (if they're a parent)
  managedAthletes Athlete[] @relation("ParentManaged")

  // Gym relationships
  gymMemberships GymMember[] // Gyms this user is a member of
  ownedGyms      Gym[]       @relation("GymOwner") // Gyms this user owns
  createdInvites GymInvite[] @relation("InviteCreator") // Invites this user created
  usedInvites    GymInviteUsage[] @relation("InviteUser") // Invites this user redeemed
  
  // Class/coaching relationships
  coachedClasses        ClassCoach[]         // Classes where user is a coach
  classMembersAdded     ClassMember[]        @relation("ClassMemberAdder") // Members this user added
  joinRequestsMade      ClassJoinRequest[]   @relation("JoinRequester")
  joinRequestsReviewed  ClassJoinRequest[]   @relation("JoinReviewer")
  classGradesGiven      ClassGrade[]         @relation("ClassGrader") // Grades given by this coach
}

enum AccountType {
  ATHLETE // Primarily competing for themselves
  PARENT  // Primarily managing child athletes (but can also compete)
}

enum Role {
  ATHLETE
  PARENT
  COACH
  GYM_ADMIN
  SYSTEM_ADMIN
}

model Athlete {
  id String @id @default(cuid())

  // For adult athletes who have their own account
  userId String? @unique
  user   User?   @relation("UserAthlete", fields: [userId], references: [id])

  // For child athletes managed by a parent
  parentId String?
  parent   User?   @relation("ParentManaged", fields: [parentId], references: [id])

  displayName String
  username    String?  @unique // For @mentions and profile URLs (URL-safe) - nullable during migration
  dateOfBirth DateTime
  gender      String // Maps to division
  avatarUrl   String?
  isMinor     Boolean  @default(false) // Calculated from DOB, for quick filtering
  
  // Privacy settings (COPPA compliance for minors)
  isPublicProfile Boolean @default(false) // Can appear in public lists (leaderboards, gym members)
  showDisplayName Boolean @default(false) // Show real name on profile (otherwise just username)
  feedVisibility  FeedVisibility @default(PUBLIC) // Who can see activity in feeds
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  domainLevels   DomainLevel[]
  xpTransactions XPTransaction[]
  submissions    ChallengeSubmission[]
  disciplines    AthleteDiscipline[]   // Primary training disciplines
  videos         Video[]               // Video library for reuse
  
  // Social: Following system
  followers      Follow[]       @relation("Following")  // People who follow this athlete
  following      Follow[]       @relation("Followers")  // People this athlete follows
  
  // Social: Reactions & Comments
  reactions      Reaction[]
  comments       Comment[]
  commentReports CommentReport[] @relation("Reporter")
  
  // Notifications
  notifications  Notification[]
  
  // Class memberships and grades
  classMembers   ClassMember[]
  classGrades    ClassGrade[]
  joinRequests   ClassJoinRequest[]
}

// Feed visibility setting
enum FeedVisibility {
  PUBLIC     // Everyone can see activity
  FOLLOWERS  // Only followers can see
  PRIVATE    // Don't show in any feeds
}

// ============================================
// VIDEO LIBRARY
// ============================================

model Video {
  id          String   @id @default(cuid())
  athleteId   String
  title       String   // User-provided title for easy identification
  url         String   // Vercel Blob URL
  thumbnailUrl String? // Auto-generated thumbnail (future)
  duration    Int?     // Duration in seconds (if known)
  fileSize    Int?     // File size in bytes
  mimeType    String?  // video/mp4, video/webm, etc.
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  athlete     Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  
  @@index([athleteId])
}

// Join table: Athlete <-> Discipline (many-to-many)
model AthleteDiscipline {
  id           String @id @default(cuid())
  athleteId    String
  disciplineId String
  createdAt    DateTime @default(now())

  athlete    Athlete    @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  discipline Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

  @@unique([athleteId, disciplineId])
}

// ============================================
// DOMAINS & CATEGORIES (Admin-Configurable)
// ============================================

model Domain {
  id          String  @id @default(cuid())
  name        String  @unique // Strength, Skill, Endurance, Speed
  slug        String  @unique
  description String?
  icon        String? // Icon name or URL
  color       String? // Hex color for UI
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  categories       Category[]
  levels           DomainLevel[]
  xpTransactions   XPTransaction[]
  xpThresholds     XPThreshold[] // Configurable XP per sublevel
  breakthroughRules BreakthroughRule[] // Rules for rank advancement

  // Challenges that award XP to this domain
  primaryChallenges   Challenge[] @relation("PrimaryDomain")
  secondaryChallenges Challenge[] @relation("SecondaryDomain")
  tertiaryChallenges  Challenge[] @relation("TertiaryDomain")
}

// XP required per sublevel, configurable per domain per rank
model XPThreshold {
  id         String @id @default(cuid())
  domainId   String
  rank       String // F, E, D, C, B, A, S
  sublevel   Int // 0-9
  xpRequired Int // XP needed to reach this sublevel
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  domain Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@unique([domainId, rank, sublevel])
}

model Category {
  id          String  @id @default(cuid())
  domainId    String
  name        String // e.g., "Balance", "Grip Strength", "Climbing"
  slug        String
  description String?
  icon        String?
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  domain     Domain      @relation(fields: [domainId], references: [id], onDelete: Cascade)
  challenges ChallengeCategory[] // Many-to-many with challenges

  @@unique([domainId, slug])
}

// ============================================
// DISCIPLINES (Sports/Activities - Admin-Configurable)
// ============================================

model Discipline {
  id          String  @id @default(cuid())
  name        String  @unique // e.g., "Ninja", "Calisthenics", "Parkour", "CrossFit"
  slug        String  @unique
  description String?
  icon        String?
  color       String? // Hex color for UI
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  challenges ChallengeDiscipline[] // Many-to-many with challenges
  equipment  DisciplineEquipment[] // Many-to-many with equipment
  gyms       GymDiscipline[]       // Many-to-many with gyms
  athletes   AthleteDiscipline[]   // Many-to-many with athletes
}

// ============================================
// EQUIPMENT (Admin-Configurable)
// ============================================

model Equipment {
  id          String  @id @default(cuid())
  name        String  @unique // e.g., "Salmon Ladder", "Warped Wall", "Pull-up Bar"
  slug        String  @unique
  description String?
  icon        String?
  imageUrl    String? // Photo of the equipment
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  challenges  ChallengeEquipment[]  // Many-to-many with challenges
  disciplines DisciplineEquipment[] // Many-to-many with disciplines
  gyms        GymEquipment[]        // Many-to-many with gyms
  packages    EquipmentPackageItem[] // Many-to-many with packages
}

// Equipment Package - a preset collection of equipment for easy gym setup
model EquipmentPackage {
  id          String  @id @default(cuid())
  name        String  @unique // e.g., "Standard Ninja Gym", "Basic Fitness Center"
  slug        String  @unique
  description String? @db.Text
  icon        String? // Emoji or icon identifier
  sortOrder   Int     @default(0)
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  items EquipmentPackageItem[]
}

// Join table: EquipmentPackage <-> Equipment
model EquipmentPackageItem {
  id          String @id @default(cuid())
  packageId   String
  equipmentId String
  quantity    Int    @default(1) // Default quantity when package is applied
  createdAt   DateTime @default(now())

  package   EquipmentPackage @relation(fields: [packageId], references: [id], onDelete: Cascade)
  equipment Equipment        @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@unique([packageId, equipmentId])
}

// Join table: Discipline <-> Equipment (many-to-many)
model DisciplineEquipment {
  id           String @id @default(cuid())
  disciplineId String
  equipmentId  String
  createdAt    DateTime @default(now())

  discipline Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)
  equipment  Equipment  @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@unique([disciplineId, equipmentId])
}

// Join table: Challenge <-> Equipment (many-to-many)
model ChallengeEquipment {
  id          String @id @default(cuid())
  challengeId String
  equipmentId String
  isRequired  Boolean @default(true) // true = required, false = optional/alternative
  notes       String? // e.g., "Can substitute with rings"
  createdAt   DateTime @default(now())

  challenge  Challenge  @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  equipment  Equipment  @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@unique([challengeId, equipmentId])
}

// ============================================
// CHALLENGES (The Core Content)
// ============================================

// Join table: Challenge <-> Division (many-to-many for allowed divisions)
model ChallengeDivision {
  id          String @id @default(cuid())
  challengeId String
  divisionId  String
  createdAt   DateTime @default(now())

  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  division  Division  @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([challengeId, divisionId])
}

// Join table: Challenge <-> Category (many-to-many)
model ChallengeCategory {
  id          String @id @default(cuid())
  challengeId String
  categoryId  String
  sortOrder   Int    @default(0) // For ordering within a category
  createdAt   DateTime @default(now())

  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  category  Category  @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([challengeId, categoryId])
}

// Join table: Challenge <-> Discipline (many-to-many)
model ChallengeDiscipline {
  id           String @id @default(cuid())
  challengeId  String
  disciplineId String
  createdAt    DateTime @default(now())

  challenge  Challenge  @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  discipline Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

  @@unique([challengeId, disciplineId])
}

// How a challenge is measured/graded
enum GradingType {
  PASS_FAIL     // Simple completion (e.g., "Complete the warped wall")
  REPS          // Count repetitions (e.g., "Pull-ups")
  TIME          // Duration in seconds (e.g., "Hold a dead hang for X seconds")
  DISTANCE      // Distance in meters/feet (e.g., "Broad jump X meters")
  TIMED_REPS    // Reps within a time limit (e.g., "Max pull-ups in 60 seconds")
  WEIGHTED_REPS // Reps at a specific weight (e.g., "10 reps at 100lbs")
}

// Graded requirements per division and rank
// Example: Pull-ups for Adult Male at C-rank = 15 reps
model ChallengeGrade {
  id           String  @id @default(cuid())
  challengeId  String
  divisionId   String
  rank         String  // F, E, D, C, B, A, S
  targetValue  Int     // The number to achieve (reps, seconds, etc.)
  targetWeight Int?    // For WEIGHTED_REPS: weight in lbs/kg per challenge weightUnit
  description  String? // Optional override text, e.g., "15 strict pull-ups"
  bonusXP      Int     @default(0) // Extra XP for this specific grade
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  division  Division  @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([challengeId, divisionId, rank])
}

model Challenge {
  id           String  @id @default(cuid())
  name         String  @unique
  slug         String  @unique
  description  String  @db.Text
  instructions String? @db.Text // How to perform/submit
  demoVideoUrl String? // Vercel Blob URL
  demoImageUrl String? // Vercel Blob URL
  isActive     Boolean @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Grading configuration
  gradingType  GradingType @default(PASS_FAIL) // How is this challenge measured?
  gradingUnit  String?     // e.g., "reps", "seconds", "meters", "feet"
  weightUnit   String?     // For WEIGHTED_REPS: "lbs" or "kg"
  timeFormat   String?     // For TIME type: "seconds", "mm:ss", "hh:mm:ss"
  minRank      String      @default("F") // Lowest rank this challenge is available for
  maxRank      String      @default("S") // Highest rank this challenge is available for

  // Proof/submission types allowed for this challenge
  proofTypes   String[]    @default(["VIDEO"]) // VIDEO, IMAGE, STRAVA, MANUAL
  
  // Activity validation rules (for Strava challenges)
  activityType      String?   // Run, Ride, Swim, Hike, Walk, etc.
  minDistance       Float?    // Minimum distance in meters
  maxDistance       Float?    // Maximum distance in meters (for time trials)
  minElevationGain  Float?    // Minimum elevation gain in meters
  requiresGPS       Boolean   @default(false) // Must be outdoor GPS activity, not treadmill
  requiresHeartRate Boolean   @default(false) // Must have HR data (proves genuine effort)

  // Gym-specific challenge (null = global challenge available to all)
  gymId String?
  gym   Gym?    @relation(fields: [gymId], references: [id], onDelete: SetNull)

  // Challenge scope: GLOBAL (admin) or CLASS (coach-created for a class)
  scope            ChallengeScope @default(GLOBAL)
  createdByClassId String?
  createdByClass   Class?         @relation("ClassChallenges", fields: [createdByClassId], references: [id], onDelete: SetNull)

  // Categories this challenge appears in (many-to-many)
  categories ChallengeCategory[]

  // Disciplines/sports this challenge belongs to (many-to-many)
  disciplines ChallengeDiscipline[]

  // Equipment required for this challenge (many-to-many)
  equipment ChallengeEquipment[]

  // Graded requirements per division/rank
  grades ChallengeGrade[]

  // Divisions allowed to attempt this challenge (empty = all divisions)
  allowedDivisions ChallengeDivision[]

  // Multi-domain XP distribution (up to 3 domains)
  // Percentages must sum to 100
  // Example: Skill 50%, Strength 40%, Speed 10%
  primaryDomainId    String  // Required - main domain for XP
  primaryXPPercent   Int     @default(100) // 50-100%
  secondaryDomainId  String? // Optional second domain
  secondaryXPPercent Int?    // 0-50%
  tertiaryDomainId   String? // Optional third domain
  tertiaryXPPercent  Int?    // 0-30%

  primaryDomain   Domain  @relation("PrimaryDomain", fields: [primaryDomainId], references: [id])
  secondaryDomain Domain? @relation("SecondaryDomain", fields: [secondaryDomainId], references: [id], onDelete: SetNull)
  tertiaryDomain  Domain? @relation("TertiaryDomain", fields: [tertiaryDomainId], references: [id], onDelete: SetNull)

  rankRequirements RankRequirement[]
  submissions      ChallengeSubmission[]
  classBenchmarks  ClassBenchmark[]
}

// ============================================
// DIVISIONS (Age/Gender - Admin-Configurable)
// ============================================

model Division {
  id        String  @id @default(cuid())
  name      String // e.g., "Youth Male 8-10", "Adult Female"
  slug      String  @unique
  gender    String? // Male, Female, or null for any
  ageMin    Int? // Minimum age (inclusive)
  ageMax    Int? // Maximum age (inclusive)
  sortOrder Int     @default(0)
  isActive  Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rankRequirements  RankRequirement[]
  rankThresholds    RankThreshold[]
  challengeGrades   ChallengeGrade[]
  breakthroughRules BreakthroughRule[] // Division-specific breakthrough overrides
  
  // Challenges that are allowed for this division
  allowedChallenges ChallengeDivision[]
}

// ============================================
// RANK REQUIREMENT MATRIX (The Rubric)
// ============================================

model RankRequirement {
  id              String  @id @default(cuid())
  challengeId     String
  divisionId      String
  requiredForRank String // F, E, D, C, B, A, S
  bonusXP         Int     @default(0) // Extra XP for this division
  isRequired      Boolean @default(true) // vs optional for rank
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  challenge Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  division  Division  @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([challengeId, divisionId, requiredForRank])
}

// How many challenges needed per category to advance rank
model RankThreshold {
  id              String  @id @default(cuid())
  divisionId      String
  domainId        String
  rank            String // The rank being unlocked (e.g., "C" means moving from D to C)
  categoryId      String? // If null, applies to whole domain
  requiredCount   Int // N of M challenges required
  totalInCategory Int? // M (optional, can be calculated)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  division Division @relation(fields: [divisionId], references: [id], onDelete: Cascade)

  @@unique([divisionId, domainId, rank, categoryId])
}

// ============================================
// ATHLETE PROGRESS
// ============================================

model DomainLevel {
  id        String @id @default(cuid())
  athleteId String
  domainId  String
  letter    String @default("F") // F, E, D, C, B, A, S
  sublevel  Int    @default(0) // 0-9
  currentXP Int    @default(0)
  bankedXP  Int    @default(0) // XP waiting for breakthrough (earned but can't level up yet)
  
  // Breakthrough tracking
  // When sublevel hits 9 and has enough XP, athlete must meet breakthrough requirements
  // to advance to the next rank letter
  breakthroughReady    Boolean  @default(false) // Has max XP for current rank, needs breakthrough
  breakthroughAchieved DateTime? // When they completed the breakthrough
  
  updatedAt DateTime @updatedAt

  athlete Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  domain  Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)

  @@unique([athleteId, domainId])
}

// ============================================
// BREAKTHROUGH RULES
// ============================================

// Defines what's required to break through from one rank to the next
// Example: To go from F ‚Üí E in Strength, achieve E-tier on 3 challenges
model BreakthroughRule {
  id          String  @id @default(cuid())
  domainId    String
  fromRank    String  // Current rank (F, E, D, C, B, A)
  toRank      String  // Target rank (E, D, C, B, A, S)
  
  // Requirement: Achieve at least [tierRequired] on [challengeCount] challenges in this domain
  tierRequired    String  // Minimum tier to count (e.g., "E" means E-tier or higher)
  challengeCount  Int     // How many challenges needed
  
  // Optional: Per-division overrides (null = applies to all divisions)
  divisionId  String?
  
  isActive    Boolean @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  domain   Domain    @relation(fields: [domainId], references: [id], onDelete: Cascade)
  division Division? @relation(fields: [divisionId], references: [id], onDelete: SetNull)

  @@unique([domainId, fromRank, toRank, divisionId])
}

model XPTransaction {
  id        String   @id @default(cuid())
  athleteId String
  domainId  String
  amount    Int
  source    XPSource
  sourceId  String? // Reference to challenge submission, competition, etc.
  note      String?
  createdAt DateTime @default(now())

  athlete Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  domain  Domain  @relation(fields: [domainId], references: [id], onDelete: Cascade)
}

enum XPSource {
  CHALLENGE
  TRAINING
  COMPETITION
  EVENT
  BONUS
  ADMIN
}

// How the submission was proven
enum ProofType {
  VIDEO       // Video upload
  IMAGE       // Image upload
  STRAVA      // Strava activity
  GARMIN      // Garmin activity (future use)
  RACE_RESULT // Official race result
  MANUAL      // Manual entry (coach/admin approved)
}

// ============================================
// CHALLENGE SUBMISSIONS
// ============================================

model ChallengeSubmission {
  id            String           @id @default(cuid())
  athleteId     String
  challengeId   String
  submittedById String // User who submitted (parent or athlete themselves)
  videoUrl      String? // Vercel Blob URL (legacy, or direct URL)
  videoId       String? // Reference to Video in library (for reuse tracking)
  imageUrl      String? // Vercel Blob URL
  notes         String?
  status        SubmissionStatus @default(PENDING)
  autoApproved  Boolean          @default(false) // True if submitter was Coach/Admin
  reviewedBy    String? // User ID of reviewer
  reviewNotes   String?
  submittedAt   DateTime         @default(now())
  reviewedAt    DateTime?

  // Proof type used for this submission
  proofType     ProofType        @default(VIDEO)
  
  // Strava activity proof
  stravaActivityId  String?
  stravaActivityUrl String?
  
  // Garmin activity proof (future use)
  garminActivityId  String?
  garminActivityUrl String?
  
  // Cached activity metrics (from Strava API)
  activityDistance   Float?    // Distance in meters
  activityTime       Int?      // Duration in seconds
  activityElevation  Float?    // Elevation gain in meters
  activityDate       DateTime? // When the activity occurred
  activityType       String?   // Run, Ride, Swim, etc.
  activityAvgHR      Int?      // Average heart rate
  activityMaxHR      Int?      // Max heart rate
  activityPolyline   String?   // Encoded polyline for route map display

  // For graded challenges: what value did they achieve?
  achievedValue  Int? // e.g., 20 reps, 45 seconds, etc.
  achievedWeight Int? // For WEIGHTED_REPS: weight used in lbs/kg
  
  // Which rank tier did they achieve? (F, E, D, C, B, A, S)
  achievedRank  String? // Calculated from achievedValue vs ChallengeGrade targets
  
  // Which tiers have been claimed for XP? (prevents re-farming)
  // Stored as comma-separated: "F,E,D,C" means F through C tiers claimed
  claimedTiers  String  @default("") // Empty = none claimed yet
  
  // Total XP awarded across all claimed tiers
  xpAwarded     Int     @default(0)

  // Privacy settings
  isPublic       Boolean @default(true)  // Show on public feeds/leaderboards
  hideExactValue Boolean @default(false) // Hide achievedValue but still show rank
  isHiddenFromFeed Boolean @default(false) // Admin-hidden from activity feeds

  // Manual entry verification - which coach supervised this attempt
  supervisorId   String? // User ID of supervising coach
  supervisorName String? // Cached name for display purposes
  
  // Level up info (for feed display when submission caused a level up)
  // JSON: { domainName, domainColor, oldLetter, oldSublevel, newLetter, newSublevel }[]
  levelUpInfo    Json?

  athlete   Athlete             @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  challenge Challenge           @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  history   SubmissionHistory[] // Previous versions
  
  // Social features
  reactions Reaction[]
  comments  Comment[]
  
  // Class grading (if created via class quick grade)
  classGrade ClassGrade?

  @@unique([athleteId, challengeId]) // One active submission per challenge per athlete
}

// Keeps history of resubmissions for audit
model SubmissionHistory {
  id           String           @id @default(cuid())
  submissionId String
  videoUrl     String?
  imageUrl     String?
  notes        String?
  status       SubmissionStatus
  reviewedBy   String?
  reviewNotes  String?
  submittedAt  DateTime
  reviewedAt   DateTime?
  version      Int
  archivedAt   DateTime         @default(now())

  submission ChallengeSubmission @relation(fields: [submissionId], references: [id], onDelete: Cascade)
}

enum SubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  NEEDS_REVISION
}

// ============================================
// FUTURE: COMPETITIONS
// ============================================

model Competition {
  id        String   @id @default(cuid())
  name      String
  date      DateTime
  location  String?
  sport     String
  domains   String[] // Which domains this affects
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  results CompetitionResult[]
}

model CompetitionResult {
  id                String   @id @default(cuid())
  competitionId     String
  athleteId         String
  placement         Int
  totalParticipants Int
  xpAwarded         Int
  createdAt         DateTime @default(now())

  competition Competition @relation(fields: [competitionId], references: [id], onDelete: Cascade)
}

// ============================================
// GYMS
// ============================================

model Gym {
  id            String  @id @default(cuid())
  name          String
  slug          String  @unique
  description   String? @db.Text
  logoUrl       String?
  bannerUrl     String?
  website       String?
  googlePlaceId String? // Google Places API place_id for Maps integration
  address       String?
  city          String?
  state         String?
  country       String?
  zipCode       String?
  phone         String?
  email         String?
  
  // Social media links
  instagramUrl  String?
  facebookUrl   String?
  tiktokUrl     String?
  youtubeUrl    String?
  
  isActive      Boolean @default(true)
  isVerified    Boolean @default(false) // Admin-verified gym
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Owner (the user who created/owns this gym)
  ownerId String
  owner   User   @relation("GymOwner", fields: [ownerId], references: [id])

  // Relationships
  members     GymMember[]      // Users who are members/staff of this gym
  equipment   GymEquipment[]   // Equipment this gym has
  disciplines GymDiscipline[]  // Disciplines this gym focuses on
  challenges  Challenge[]      // Gym-specific challenges
  classes     Class[]          // Classes at this gym
  invites     GymInvite[]      // Invite links for this gym
}

// Gym membership role
enum GymRole {
  MEMBER  // Regular member
  COACH   // Can review submissions
  MANAGER // Can manage gym settings, equipment, challenges
  OWNER   // Full control (set automatically for gym creator)
}

// Join table: User <-> Gym (many-to-many with role)
model GymMember {
  id        String   @id @default(cuid())
  gymId     String
  userId    String
  role      GymRole  @default(MEMBER)
  joinedAt  DateTime @default(now())
  isActive  Boolean  @default(true)
  
  // Privacy: whether to show on public gym member list
  // Only applies if user's athlete profile also has isPublicProfile=true
  isPublicMember Boolean @default(false)

  gym  Gym  @relation(fields: [gymId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([gymId, userId])
}

// Join table: Gym <-> Equipment (what equipment the gym has)
model GymEquipment {
  id          String   @id @default(cuid())
  gymId       String
  equipmentId String
  quantity    Int      @default(1) // How many of this equipment
  notes       String?  // e.g., "14ft warped wall"
  createdAt   DateTime @default(now())

  gym       Gym       @relation(fields: [gymId], references: [id], onDelete: Cascade)
  equipment Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)

  @@unique([gymId, equipmentId])
}

// Join table: Gym <-> Discipline (what disciplines the gym focuses on)
model GymDiscipline {
  id           String   @id @default(cuid())
  gymId        String
  disciplineId String
  isPrimary    Boolean  @default(false) // Main discipline for the gym
  createdAt    DateTime @default(now())

  gym        Gym        @relation(fields: [gymId], references: [id], onDelete: Cascade)
  discipline Discipline @relation(fields: [disciplineId], references: [id], onDelete: Cascade)

  @@unique([gymId, disciplineId])
}

// ============================================
// SOCIAL: FOLLOWING SYSTEM
// ============================================

model Follow {
  id          String   @id @default(cuid())
  followerId  String   // The athlete doing the following
  followingId String   // The athlete being followed
  createdAt   DateTime @default(now())

  follower  Athlete @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  following Athlete @relation("Following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

// ============================================
// SOCIAL: REACTIONS
// ============================================

model Reaction {
  id           String   @id @default(cuid())
  athleteId    String   // Who reacted
  submissionId String?  // Reaction on a submission
  commentId    String?  // Reaction on a comment
  emoji        String   // üî• üí™ üëè üéØ ‚ö°
  createdAt    DateTime @default(now())

  athlete    Athlete              @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  submission ChallengeSubmission? @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  comment    Comment?             @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([athleteId, submissionId, emoji])
  @@unique([athleteId, commentId, emoji])
  @@index([submissionId])
  @@index([commentId])
}

// ============================================
// SOCIAL: COMMENTS
// ============================================

model Comment {
  id           String   @id @default(cuid())
  athleteId    String   // Who wrote the comment
  submissionId String   // Which submission it's on
  parentId     String?  // For nested replies (null = top-level comment)
  content      String   @db.Text // Max 2000 chars enforced in app
  depth        Int      @default(0) // 0 = top-level, 1 = reply, 2 = reply-to-reply (max 3)
  isDeleted    Boolean  @default(false) // Soft delete (keeps structure for replies)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  athlete    Athlete              @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  submission ChallengeSubmission  @relation(fields: [submissionId], references: [id], onDelete: Cascade)
  parent     Comment?             @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies    Comment[]            @relation("CommentReplies")
  reactions  Reaction[]
  reports    CommentReport[]

  @@index([submissionId])
  @@index([parentId])
}

// ============================================
// SOCIAL: COMMENT REPORTS
// ============================================

model CommentReport {
  id          String       @id @default(cuid())
  commentId   String
  reporterId  String       // Athlete who reported
  reason      String       // Why they reported it
  status      ReportStatus @default(PENDING)
  reviewedBy  String?      // Admin user ID who reviewed
  reviewNotes String?      // Admin notes on resolution
  reviewedAt  DateTime?
  createdAt   DateTime     @default(now())

  comment  Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  reporter Athlete @relation("Reporter", fields: [reporterId], references: [id], onDelete: Cascade)

  @@index([commentId])
  @@index([status])
}

enum ReportStatus {
  PENDING      // Awaiting review
  REVIEWED     // Reviewed, no action needed
  DISMISSED    // Report was invalid/spam
  ACTION_TAKEN // Comment was removed or user warned
}

// ============================================
// NOTIFICATIONS
// ============================================

model Notification {
  id          String           @id @default(cuid())
  athleteId   String           // Who receives the notification
  type        NotificationType
  title       String           // Short title (e.g., "New follower!")
  body        String?          // Longer description
  linkUrl     String?          // Where to navigate when clicked
  isRead      Boolean          @default(false)
  
  // Metadata for rendering (actor info, submission info, etc.)
  actorId       String?  // Athlete who triggered the notification
  actorUsername String?  // Cached for display without extra query
  actorAvatar   String?  // Cached avatar URL
  submissionId  String?  // Related submission
  commentId     String?  // Related comment
  
  createdAt   DateTime @default(now())

  athlete Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)

  @@index([athleteId, isRead])
  @@index([athleteId, createdAt])
}

enum NotificationType {
  FOLLOW          // Someone followed you
  REACTION        // Someone reacted to your submission
  COMMENT         // Someone commented on your submission
  COMMENT_REPLY   // Someone replied to your comment
  COMMENT_LIKE    // Someone liked your comment
  LEVEL_UP        // You leveled up
  TRAINING_SYNC   // Activity synced from Strava/Garmin
  SUBMISSION_APPROVED // Your submission was approved
  SUBMISSION_REJECTED // Your submission was rejected
  CLASS_ADDED     // You were added to a class
  CLASS_JOIN_REQUEST  // Someone wants to join your class
  CLASS_REQUEST_APPROVED // Your join request was approved
  CLASS_REQUEST_DENIED   // Your join request was denied
  CLASS_GRADE     // Coach graded your submission
}

// ============================================
// CLASSES & COACHING
// ============================================

model Class {
  id          String   @id @default(cuid())
  name        String   // e.g., "Tuesday Ninja Kids"
  description String?  @db.Text
  schedule    String?  // e.g., "Tuesdays 5-6pm"
  
  // Optional gym association
  gymId       String?
  gym         Gym?     @relation(fields: [gymId], references: [id], onDelete: SetNull)
  
  // Visibility and enrollment
  isPublic         Boolean @default(true)  // Visible to non-gym members
  requiresApproval Boolean @default(true)  // Join requests need coach approval
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  coaches      ClassCoach[]
  members      ClassMember[]
  benchmarks   ClassBenchmark[]
  joinRequests ClassJoinRequest[]
  
  // Challenges created specifically for this class (max 1)
  createdChallenges Challenge[] @relation("ClassChallenges")
}

model ClassCoach {
  id          String         @id @default(cuid())
  classId     String
  userId      String
  role        ClassCoachRole @default(COACH)
  isHeadCoach Boolean        @default(false)
  createdAt   DateTime       @default(now())
  
  class Class @relation(fields: [classId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([classId, userId])
}

enum ClassCoachRole {
  COACH     // Full access
  ASSISTANT // Future: limited permissions
}

model ClassMember {
  id        String            @id @default(cuid())
  classId   String
  athleteId String
  addedById String            // User who added them (coach or parent self-request approved)
  status    ClassMemberStatus @default(ACTIVE)
  joinedAt  DateTime          @default(now())
  leftAt    DateTime?
  
  class   Class   @relation(fields: [classId], references: [id], onDelete: Cascade)
  athlete Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  addedBy User    @relation("ClassMemberAdder", fields: [addedById], references: [id])
  
  @@unique([classId, athleteId])
}

enum ClassMemberStatus {
  ACTIVE  // Currently enrolled
  REMOVED // Removed by coach
  LEFT    // Self-removed by athlete/parent
}

model ClassJoinRequest {
  id            String            @id @default(cuid())
  classId       String
  athleteId     String
  requestedById String            // User who made the request (parent or adult athlete)
  status        JoinRequestStatus @default(PENDING)
  note          String?           // Optional message from requester
  reviewedById  String?           // Coach who approved/denied
  reviewedAt    DateTime?
  createdAt     DateTime          @default(now())
  
  class       Class   @relation(fields: [classId], references: [id], onDelete: Cascade)
  athlete     Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  requestedBy User    @relation("JoinRequester", fields: [requestedById], references: [id])
  reviewedBy  User?   @relation("JoinReviewer", fields: [reviewedById], references: [id])
  
  @@unique([classId, athleteId]) // One pending request per athlete per class
}

enum JoinRequestStatus {
  PENDING
  APPROVED
  DENIED
}

model ClassBenchmark {
  id          String    @id @default(cuid())
  classId     String
  challengeId String
  targetTier  String?   // Target tier for athletes (F, E, D, C, B, A, S)
  dueDate     DateTime? // Optional due date for completing the benchmark
  sortOrder   Int       @default(0)
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  
  class     Class       @relation(fields: [classId], references: [id], onDelete: Cascade)
  challenge Challenge   @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  grades    ClassGrade[]
  
  @@unique([classId, challengeId])
}

model ClassGrade {
  id           String   @id @default(cuid())
  benchmarkId  String
  athleteId    String
  gradedById   String   // Coach who graded
  submissionId String?  @unique // Links to ChallengeSubmission created
  
  // Result (cached for quick display, source of truth is submission)
  achievedValue Float?   // Reps, time, distance
  passed        Boolean? // For pass/fail challenges
  achievedTier  String?  // F, E, D, C, B, A, S
  notes         String?
  
  gradedAt  DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  benchmark  ClassBenchmark       @relation(fields: [benchmarkId], references: [id], onDelete: Cascade)
  athlete    Athlete              @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  gradedBy   User                 @relation("ClassGrader", fields: [gradedById], references: [id])
  submission ChallengeSubmission? @relation(fields: [submissionId], references: [id], onDelete: SetNull)
  
  @@unique([benchmarkId, athleteId]) // One grade per athlete per benchmark
}

// Challenge scope: Global (admin-created) vs Class (coach-created for a class)
enum ChallengeScope {
  GLOBAL // Admin-created, visible to everyone
  CLASS  // Coach-created for a class, visible only to class members
}

// ============================================
// SUPPORT TICKETS
// ============================================

model SupportTicket {
  id        String   @id @default(cuid())
  
  // Contact info (may or may not be logged in)
  email     String
  name      String?
  userId    String?  // If logged in, link to user
  athleteId String?  // If logged in and has athlete profile
  
  // Ticket details
  subject   String
  message   String
  category  SupportCategory @default(OTHER)
  
  // Status tracking
  status    TicketStatus @default(OPEN)
  priority  TicketPriority @default(NORMAL)
  
  // Admin notes (internal)
  adminNotes String?
  resolvedAt DateTime?
  resolvedBy String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([email])
  @@index([status])
  @@index([createdAt])
}

enum SupportCategory {
  BUG           // Something isn't working
  ACCOUNT       // Account or login issues
  CHALLENGE     // Challenge-related questions
  SUBMISSION    // Submission issues
  GYM           // Gym-related questions
  FEATURE       // Feature request
  OTHER         // General inquiry
}

enum TicketStatus {
  OPEN          // New ticket
  IN_PROGRESS   // Being worked on
  WAITING       // Waiting for user response
  RESOLVED      // Issue resolved
  CLOSED        // Closed (no resolution needed)
}

enum TicketPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// ============================================
// GYM INVITES
// ============================================

model GymInvite {
  id          String   @id @default(cuid())
  gymId       String
  token       String   @unique @default(cuid()) // Unique invite token for URL
  role        GymRole  @default(COACH)          // Role to assign on join
  createdById String                             // User who created the invite
  
  // Usage tracking
  maxUses     Int?                               // Max number of uses (null = unlimited)
  useCount    Int      @default(0)               // How many times it's been used
  
  // Expiration
  expiresAt   DateTime                           // When invite expires
  
  // Status
  isActive    Boolean  @default(true)            // Can be revoked
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  gym       Gym                @relation(fields: [gymId], references: [id], onDelete: Cascade)
  createdBy User               @relation("InviteCreator", fields: [createdById], references: [id])
  usages    GymInviteUsage[]
  
  @@index([gymId])
  @@index([token])
}

// Track who used each invite
model GymInviteUsage {
  id        String   @id @default(cuid())
  inviteId  String
  userId    String
  usedAt    DateTime @default(now())
  
  invite GymInvite @relation(fields: [inviteId], references: [id], onDelete: Cascade)
  user   User      @relation("InviteUser", fields: [userId], references: [id])
  
  @@unique([inviteId, userId]) // User can only use an invite once
}
